2019-November-01 - dev-meeting
==============================

### async refactoring

#### background

A few weeks ago, I created an internal demo url-endpoint showing five hits to `https://httpbin.org/delay/x`, where x is .6, .8, 1, 1.2, and 1.4, showing that whereas normal procedural programming would result in the response taking about 5 seconds, in this case it takes closer to 1.5 seconds -- because of the use of the asychronous python library, [trio](https://github.com/python-trio/trio).

I made this proof-of-concept because one of the url endpoints in the [availability-api](https://library.brown.edu/availability_api/v2/bib_items/b1815113/) has to make, behind-the-scenes, four different http calls to obtain the required data for the response. It's fast enough for it's purpose, but this is the kind of use-case that could definitely benefit from an asynchronous refactor.

Reviewing trio, I re-read a _terrific_ blog-post by the trio author, Nathaniel J. Smith, "[Notes on structured concurrency, or: Go statement considered harmful](https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)". This, truly, is one of my favorite tech-reads of the last year (at least). It posits that modern-day programming-languages don't have the necessary structures for _conceptually_ making async programming as easy as it could be, and explains his approach to this situation, in trio.

#### last weekend

(This is low-priority, so I noodle when I can.) I decided to flesh out the proof-of-concept a bit, by stubbing functions close to the actual code I'd put into place. In undertaking the [first working refactor](https://github.com/Brown-University-Library/availability_api/blob/b1b55752e60e382c40a68dbb3441e57e5211512c/availability_app/lib/bib_items_async_v2.py#L53-L59) (all urls still go to `httpbin.org`; "working" means the flow works), I realized I couldn't make all four calls simultaneously, because two of the calls were dependent on getting an authentication-token. Thus the two-stage implementation where I make two async calls -- one for the toke and one for independent data.

But then I realized that in this implementation, if the token-response was fast, and the independent-data-response was slow, I was implementing an unnecessary wait. So I refactored. There are still two stages, but they're more sensible.

The [first stage](https://github.com/Brown-University-Library/availability_api/blob/master/availability_app/lib/bib_items_async_v2.py#L30-L34) initiates the same two async requests as before.

But this time, I don't wait on the independent-data-response: Now, once the token is obtained, I immediately make the [other two async requests](https://github.com/Brown-University-Library/availability_api/blob/master/availability_app/lib/bib_items_async_v2.py#L74-L77) dependent on the token.

This flow, too works (again, with the `httpbin.org` calls). But the _cool_ thing about this refactor work is that I was able to do 'normal' high-level refactoring thinking without having to get unnecessarily deep into the weeds of the specifics of handling async code. That's exactly the promise of Smith's approach to implement intuitive language-structures for async programming.


---

---
